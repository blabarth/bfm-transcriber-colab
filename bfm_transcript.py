# -*- coding: utf-8 -*-
"""BFM_Transcript3

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1jCmx6h1YmNLfQ4qlXbcWDuuoz0jCRS-5
"""

# === Cellule 1 ‚Äî Bootstrap STABLE (Torch 2.6 CPU + WhisperX 3.4.2) ===
!apt-get -y install ffmpeg

# Nettoyage (ignore les warnings si "not installed")
!pip -q uninstall -y torch torchaudio torchvision whisperx whisper pyannote-audio pyannote.audio pandas pytorch-lightning lightning fastai || true

# Pip √† jour
!pip -q install --upgrade pip

# PyTorch CPU: versions appari√©es et coh√©rentes
!pip -q install --index-url https://download.pytorch.org/whl/cpu \
  torch==2.6.0+cpu torchaudio==2.6.0+cpu torchvision==0.21.0+cpu

# Pandas requis par WhisperX (ignore le warning Colab qui veut 2.2.2)
!pip -q install pandas==2.2.3

# Whisper (OpenAI)
!pip -q install git+https://github.com/openai/whisper.git

# Diarisation
!pip -q install "pyannote.audio==3.3.2" huggingface_hub

# WhisperX sans d√©pendances pour ne pas toucher √† Torch
!pip -q install --no-deps whisperx==3.4.2

# Outils mail & audio
!pip -q install yagmail python-dotenv pydub soundfile

# === Cellule 2 ‚Äî Configuration ===
from pathlib import Path

# ====== PARAM√àTRES √Ä √âDITER ======
# Flux audio √† enregistrer
STREAM_URL = "http://audio.bfmtv.com/bfmbusiness_128.mp3"

# Pour les tests rapides (en secondes). En production: 3600 (1h)
TEST_DURATION_SEC = 60

# Email (utilise un mot de passe d'application Gmail SANS espaces)
EMAIL_EXPEDITEUR = "bfmbusinesstranscript@gmail.com"
MOT_DE_PASSE_APP = "jyliowzbiqhvxboc"
EMAIL_DESTINATAIRES = ["blabarth@gmail.com"]  # tu peux en mettre plusieurs

# Diarisation (optionnelle) ‚Äî si vide => pas de diarisation
HUGGINGFACE_TOKEN = "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"  # Ton token Hugging Face

# R√©pertoire de travail temporaire
WORKDIR = Path("/content/bfm_transcriber_run")
WORKDIR.mkdir(parents=True, exist_ok=True)
print("üìÇ Dossier de travail:", WORKDIR)

# === Cellule 3 ‚Äî Utilitaires (enregistrement / email / nettoyage) ===
import subprocess, os, datetime, time, yagmail

def hour_label(dt=None):
    """
    Retourne une √©tiquette horaire du type '14h-15h'.
    """
    if dt is None:
        dt = datetime.datetime.now()
    h = dt.hour
    return f"{h:02d}h-{(h+1)%24:02d}h"

def timestamp_now():
    """
    Retourne un timestamp au format YYYY-MM-DD_HH-MM.
    """
    return datetime.datetime.now().strftime("%Y-%m-%d_%H-%M")

def record_wav(stream_url, out_wav, duration_sec=3600, sr=16000):
    """
    Enregistre le flux audio -> WAV mono 16 kHz via ffmpeg.
    Retourne True si un fichier non vide est cr√©√©.
    """
    cmd = [
        "ffmpeg","-loglevel","error","-y",
        "-i", stream_url,
        "-t", str(duration_sec),
        "-ar", str(sr), "-ac", "1",
        out_wav
    ]
    try:
        result = subprocess.run(
            cmd,
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE,
            timeout=duration_sec+60
        )
        return result.returncode == 0 and os.path.exists(out_wav) and os.path.getsize(out_wav) > 0
    except Exception:
        return False

def send_email(expediteur, mdp_app, dests, subject, body, attachments=None):
    """
    Envoie un email via Gmail.
    """
    yag = yagmail.SMTP(expediteur, mdp_app)
    yag.send(to=dests, subject=subject, contents=body, attachments=attachments)

def cleanup_files(*paths):
    """
    Supprime en silence les fichiers list√©s.
    """
    for p in paths:
        try:
            if p and os.path.exists(p):
                os.remove(p)
        except Exception:
            pass

# === Cellule 4 ‚Äî Transcription + Diarisation (optionnelle) ‚Äî version "group√©e par locuteur" ===
from typing import Optional
import whisper, torch

# Import optionnel de whisperx et d√©tection de la classe de diarisation selon la version
try:
    import whisperx
    if hasattr(whisperx, "DiarizationPipeline"):
        DiarizationPipeline = whisperx.DiarizationPipeline
    else:
        from whisperx.diarize import DiarizationPipeline
except Exception:
    whisperx = None
    DiarizationPipeline = None

def transcribe_and_diarize(
    wav_path: str,
    out_txt_path: str,
    out_speakers_txt_path: Optional[str] = None,
    language: str = "fr",
    whisper_model_name: str = "base",
    hf_token: str = ""
) -> dict:
    """
    1) Transcrit avec Whisper (texte brut -> out_txt_path).
    2) Si token HF fourni ET WhisperX disponible, diarise et √©crit un fichier "speakers"
       avec une seule ligne par tour de parole (speaker + timecode du 1er au dernier segment).
    Retour: {"diarization": bool, "segments": [...]}
    """
    # --- Transcription Whisper ---
    wmodel = whisper.load_model(whisper_model_name)
    result = wmodel.transcribe(wav_path, fp16=False, language=language)

    # Texte brut
    with open(out_txt_path, "w", encoding="utf-8") as f:
        f.write((result.get("text") or "").strip())

    # Si pas de diarisation possible, on sort ici
    if not hf_token or DiarizationPipeline is None or whisperx is None:
        return {"diarization": False, "segments": result.get("segments", [])}

    device = "cuda" if torch.cuda.is_available() else "cpu"

    # Alignement pour am√©liorer l'attribution mots <-> temps
    model_a, metadata = whisperx.load_align_model(language_code=language, device=device)
    aligned = whisperx.align(result.get("segments", []), model_a, metadata, wav_path, device)

    # Diarisation (pyannote) via WhisperX
    try:
        diarize_pipeline = DiarizationPipeline(use_auth_token=hf_token, device=device)
        diarize_segments = diarize_pipeline(wav_path)
        assigned = whisperx.assign_word_speakers(diarize_segments, aligned)
    except Exception as e:
        print("‚ö†Ô∏è Diarisation indisponible :", e)
        return {"diarization": False, "segments": result.get("segments", [])}

    # --- Export speakers: regrouper les segments cons√©cutifs du m√™me locuteur ---
    if out_speakers_txt_path:
        segs = assigned.get("segments", [])
        with open(out_speakers_txt_path, "w", encoding="utf-8") as f:
            last_spk: Optional[str] = None
            turn_start: Optional[float] = None
            turn_end: Optional[float] = None
            turn_texts = []

            def flush_turn():
                if last_spk is None:
                    return
                text = " ".join(t.strip() for t in turn_texts if t and t.strip())
                f.write(f"[{turn_start:6.1f}s-{turn_end:6.1f}s] {last_spk}: {text}\n\n")

            for seg in segs:
                spk = seg.get("speaker", "Speaker ?")
                start = float(seg.get("start", 0.0))
                end = float(seg.get("end", 0.0))
                text = (seg.get("text") or "").strip()

                if last_spk is None:
                    # premier segment
                    last_spk = spk
                    turn_start = start
                    turn_end = end
                    turn_texts = [text] if text else []
                    continue

                if spk == last_spk:
                    # m√™me locuteur -> on √©tend l'intervalle et on concat√®ne
                    turn_end = max(turn_end, end)
                    if text:
                        turn_texts.append(text)
                else:
                    # changement de locuteur -> on √©crit le "tour" pr√©c√©dent
                    flush_turn()
                    last_spk = spk
                    turn_start = start
                    turn_end = end
                    turn_texts = [text] if text else []

            # Dernier tour
            flush_turn()

    return {"diarization": True, "segments": assigned.get("segments", [])}

# === Cellule 5 ‚Äî Pipeline d‚Äôune tranche (end-to-end) ===
from pathlib import Path
import os

def process_tranche(duration_sec=3600, email_dests=None):
    """
    1) Enregistre 'duration_sec' secondes du flux STREAM_URL en WAV 16 kHz.
    2) Transcrit (Whisper) + diarise si HUGGINGFACE_TOKEN et whisperx dispo.
    3) Envoie le/les fichiers par email.
    4) Nettoie les fichiers temporaires.
    Retourne True si tout s‚Äôest bien pass√©, False sinon.
    """
    heure_str = hour_label()
    ts = timestamp_now()
    base = f"bfm_{ts}"

    wav_path = str((WORKDIR / f"{base}.wav").resolve())
    txt_path = str((WORKDIR / f"{base}.txt").resolve())
    speakers_txt_path = str((WORKDIR / f"{base}.speakers.txt").resolve()) if HUGGINGFACE_TOKEN else None

    print(f"üéôÔ∏è [{heure_str}] Enregistrement {duration_sec}s‚Ä¶")
    ok = record_wav(STREAM_URL, wav_path, duration_sec=duration_sec)
    if not ok:
        print("‚ùå Enregistrement rat√© (flux coup√© ?).")
        cleanup_files(wav_path)
        return False

    print(f"‚úçÔ∏è [{heure_str}] Transcription‚Ä¶ (diarisation: {'ON' if HUGGINGFACE_TOKEN else 'OFF'})")
    info = transcribe_and_diarize(
        wav_path=wav_path,
        out_txt_path=txt_path,
        out_speakers_txt_path=speakers_txt_path,
        language="fr",
        whisper_model_name="base",
        hf_token=HUGGINGFACE_TOKEN
    )
    print(f"‚úÖ Transcription OK. Diarisation: {'oui' if info.get('diarization') else 'non'}")

    subject = f"Transcription BFM Business ‚Äì {heure_str} ‚Äì {ts}"
    body = (
        f"Transcript pour {heure_str}.\n"
        f"Diarisation: {'oui' if info.get('diarization') else 'non'}\n"
        f"Flux: {STREAM_URL}"
    )
    attachments = [p for p in [txt_path, speakers_txt_path] if p and os.path.exists(p)]

    try:
        dests = email_dests if email_dests else EMAIL_DESTINATAIRES
        send_email(EMAIL_EXPEDITEUR, MOT_DE_PASSE_APP, dests, subject, body, attachments)
        print(f"üìß Email envoy√© √† {dests}")
    except Exception as e:
        print("‚ö†Ô∏è √âchec envoi email:", e)

    cleanup_files(wav_path, txt_path, speakers_txt_path)
    print("üßπ Fichiers temporaires supprim√©s.")
    return True

# === Cellule 6 ‚Äî Test rapide (60s) ===
ok = process_tranche(duration_sec=TEST_DURATION_SEC, email_dests=EMAIL_DESTINATAIRES)
print("RESULTAT TEST =", ok)

# === Cellule 7 ‚Äî Simulation multi-tranches / robustesse ===
# En production on utilisera cron c√¥t√© serveur.
# Ici on simule 2 tranches de 30s pour valider la relance en cas d‚Äô√©chec d‚Äôenregistrement.

for i in range(2):
    print(f"\n===== Tranche simul√©e #{i+1} =====")
    ok = process_tranche(duration_sec=30, email_dests=EMAIL_DESTINATAIRES)
    if not ok:
        print("‚õëÔ∏è Flux KO ‚Äî on r√©essaie dans 10s‚Ä¶")
        time.sleep(10)
        ok = process_tranche(duration_sec=30, email_dests=EMAIL_DESTINATAIRES)

print("\n‚úÖ Simulation termin√©e.")